from torchvision import transforms
from torchvision.datasets import MNIST
from torch.utils.data import DataLoader
import torch
import torch.nn as nn
from generator import Generator
from discriminator import Discriminator
from utils import noise_generator,show_tensor_images,tensorboard_writer    

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

def get_dataloader(batch_size):
    dataloader = DataLoader(MNIST('.',transform=transforms.ToTensor(),download=True),batch_size=batch_size,shuffle=True)
    return dataloader

def discriminator_loss(generator,discriminator,criterion,real,num_images,z_dim):
    noise = noise_generator(num_images,z_dim)
    gen_out = generator(noise)
    # discriminator output on fake images generated by generator
    disc_fake_out = discriminator(gen_out.detach())
    # calculating loss on fake images as discrimiator wants theses images to be fake(0)
    disc_fake_loss = criterion(disc_fake_out,torch.zeros_like(disc_fake_out))

    #discriminator output on real images
    disc_real_out = discriminator(real)
    # calculating loss on real images as discrimiator wants theses images to be real(1) 
    disc_real_loss = criterion(disc_real_out,torch.ones_like(disc_real_out))

    #averaging both loss
    disc_loss = (disc_real_loss+disc_fake_loss)/2

    return disc_loss


def generator_loss(generator,discriminator,criterion,num_images,z_dim):
    noise = noise_generator(num_images,z_dim)
    gen_out = generator(noise)
    # discriminator output on fake images generated by generator
    gen_fake_out = discriminator(gen_out)
    # calculating loss on fake images as generator wants discrimiator to treat theses images as real(1)
    gen_fake_loss = criterion(gen_fake_out,torch.ones_like(gen_fake_out))
    
    return gen_fake_loss

def train(n_epochs=200,batch_size=128,lr=0.00001,z_dim=64,hidden_dim=128):
    cur_step = 0
    display_step = 500
    criterion = nn.BCEWithLogitsLoss()
    mean_discriminator_loss = 0
    mean_generator_loss = 0
    # generator model with optimizer
    generator = Generator(z_dim=z_dim,img_dim=784,hidden_dim=hidden_dim).to(device)
    generator_opt = torch.optim.Adam(generator.parameters(),lr=lr)

    # discriminator model with optimizer
    discriminator = Discriminator(img_dim=784,hidden_dim=hidden_dim).to(device)
    discriminator_opt = torch.optim.Adam(discriminator.parameters(),lr=lr)

    dataloader = get_dataloader(batch_size)
    
    for epoch in range(n_epochs):
        for real, _ in dataloader:
            cur_batch_size = len(real)
            
            # Flatten the batch of real images from the dataset
            real = real.view(cur_batch_size, -1).to(device)

            # Zero out the gradients before backpropagation
            discriminator_opt.zero_grad()

            # Calculate discriminator loss
            disc_loss = discriminator_loss(generator, discriminator, criterion, real, cur_batch_size, z_dim)

            # Update gradients
            disc_loss.backward(retain_graph=True)

            # Update optimizer
            discriminator_opt.step()
            
            # Zero out the gradients before backpropagation
            generator_opt.zero_grad()
            
            # Calculate generator loss
            gen_loss = generator_loss(generator, discriminator, criterion, cur_batch_size, z_dim)
            
            # Update gradients
            gen_loss.backward(retain_graph=True)
            
            # Update optimizer
            generator_opt.step()

             # Keep track of the average discriminator loss
            mean_discriminator_loss += disc_loss.item() / display_step

            # Keep track of the average generator loss
            mean_generator_loss += gen_loss.item() / display_step

            if cur_step % display_step == 0 and cur_step > 0:
                print(f"Epoch {epoch}, step {cur_step}: Generator loss: {mean_generator_loss}, discriminator loss: {mean_discriminator_loss}")
                fake_noise = noise_generator(cur_batch_size, z_dim)
                fake = generator(fake_noise)
                generated_image_grid = show_tensor_images(fake,tensorboard_writer=True)
                tensorboard_writer(generated_image_grid,epoch,cur_step,gen_image=True)
                real_image_grid = show_tensor_images(real,tensorboard_writer=True)
                tensorboard_writer(real_image_grid,epoch,cur_step,gen_image=False)
                mean_generator_loss = 0
                mean_discriminator_loss = 0
            cur_step += 1

        


    


